/**
 * Report Generator Utility
 * Phase 252: Generate PDF reports for sensor data analysis
 *
 * Features:
 * - PDF report generation
 * - HTML report generation
 * - Chart image embedding
 * - File sharing
 */

import {Platform, Share} from 'react-native';
import RNFS from 'react-native-fs';
import type {ComprehensiveAnalysis} from './dataAnalysis';
import {formatAnalysisReport} from './dataAnalysis';
import {logger} from './logger';

export interface ReportOptions {
  sessionId: string;
  sensorType: string;
  axis: string;
  analysis: ComprehensiveAnalysis;
  includeCharts?: boolean;
  chartImages?: {
    line?: string; // Base64 or file path
    histogram?: string;
    frequency?: string;
  };
}

export interface ReportResult {
  success: boolean;
  filePath?: string;
  error?: string;
}

/**
 * Generate HTML content for the report
 */
function generateHTMLReport(options: ReportOptions): string {
  const {sessionId, sensorType, axis, analysis} = options;
  const timestamp = new Date().toLocaleString('ko-KR');

  const textReport = formatAnalysisReport(analysis, sensorType, axis);

  // Convert markdown-style report to HTML
  const htmlContent = textReport
    .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
    .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
    .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
    .replace(/^- (.*?)$/gm, '<li>$1</li>')
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>');

  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>센서 데이터 분석 리포트 - ${sessionId}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #fff;
    }
    h1 {
      color: #007AFF;
      border-bottom: 3px solid #007AFF;
      padding-bottom: 10px;
      margin-top: 30px;
    }
    h2 {
      color: #333;
      border-bottom: 1px solid #ddd;
      padding-bottom: 8px;
      margin-top: 25px;
    }
    h3 {
      color: #555;
      margin-top: 20px;
    }
    p {
      margin: 10px 0;
    }
    li {
      margin: 5px 0;
      margin-left: 20px;
    }
    .header {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .metadata {
      color: #666;
      font-size: 14px;
      margin-top: 10px;
    }
    .summary {
      background: #e3f2fd;
      padding: 15px;
      border-left: 4px solid #007AFF;
      border-radius: 4px;
      margin: 20px 0;
    }
    .chart {
      margin: 20px 0;
      text-align: center;
    }
    .chart img {
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
      text-align: center;
      color: #999;
      font-size: 12px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    th, td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th {
      background: #f8f9fa;
      font-weight: 600;
    }
    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
    }
    .badge-success {
      background: #d4edda;
      color: #155724;
    }
    .badge-warning {
      background: #fff3cd;
      color: #856404;
    }
    .badge-info {
      background: #d1ecf1;
      color: #0c5460;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>센서 데이터 분석 리포트</h1>
    <div class="metadata">
      <p><strong>세션 ID:</strong> ${sessionId}</p>
      <p><strong>센서:</strong> ${sensorType}</p>
      <p><strong>축:</strong> ${axis}</p>
      <p><strong>생성일시:</strong> ${timestamp}</p>
    </div>
  </div>

  <div class="summary">
    <h2>요약</h2>
    <p>${analysis.summary}</p>
  </div>

  ${options.includeCharts && options.chartImages ? generateChartSection(options.chartImages) : ''}

  <div class="content">
    ${htmlContent}
  </div>

  ${analysis.classification ? generateClassificationBadge(analysis.classification.activity) : ''}

  <div class="footer">
    <p>Generated by KooDTX Sensor App</p>
    <p>${timestamp}</p>
  </div>
</body>
</html>
  `.trim();

  return html;
}

/**
 * Generate chart images section for HTML
 */
function generateChartSection(chartImages: {
  line?: string;
  histogram?: string;
  frequency?: string;
}): string {
  const charts: string[] = [];

  if (chartImages.line) {
    charts.push(`
      <div class="chart">
        <h3>시계열 그래프</h3>
        <img src="${chartImages.line}" alt="Time Series Chart">
      </div>
    `);
  }

  if (chartImages.histogram) {
    charts.push(`
      <div class="chart">
        <h3>히스토그램</h3>
        <img src="${chartImages.histogram}" alt="Histogram">
      </div>
    `);
  }

  if (chartImages.frequency) {
    charts.push(`
      <div class="chart">
        <h3>주파수 스펙트럼</h3>
        <img src="${chartImages.frequency}" alt="Frequency Spectrum">
      </div>
    `);
  }

  return charts.length > 0 ? `<div class="charts">${charts.join('')}</div>` : '';
}

/**
 * Generate classification badge HTML
 */
function generateClassificationBadge(activity: string): string {
  const activityLabels: Record<string, string> = {
    stationary: '정지',
    walking: '걷기',
    running: '달리기',
    vibrating: '진동',
    unknown: '알 수 없음',
  };

  const badgeClass =
    activity === 'unknown' ? 'badge-warning' : 'badge-success';

  return `
    <div style="text-align: center; margin: 20px 0;">
      <span class="badge ${badgeClass}">
        분류: ${activityLabels[activity] || activity}
      </span>
    </div>
  `;
}

/**
 * Generate text report and save to file
 *
 * @param options - Report generation options
 * @returns Result with file path
 */
export async function generateTextReport(
  options: ReportOptions
): Promise<ReportResult> {
  try {
    const {sessionId, sensorType, axis, analysis} = options;
    const textReport = formatAnalysisReport(analysis, sensorType, axis);

    // Create file path
    const fileName = `analysis_${sessionId}_${sensorType}_${axis}_${Date.now()}.txt`;
    const filePath = `${RNFS.DocumentDirectoryPath}/${fileName}`;

    // Write to file
    await RNFS.writeFile(filePath, textReport, 'utf8');

    logger.info('Text report generated:', filePath);

    return {
      success: true,
      filePath,
    };
  } catch (error) {
    logger.error('Failed to generate text report:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Generate HTML report and save to file
 *
 * @param options - Report generation options
 * @returns Result with file path
 */
export async function generateHTMLReportFile(
  options: ReportOptions
): Promise<ReportResult> {
  try {
    const htmlContent = generateHTMLReport(options);

    // Create file path
    const fileName = `analysis_${options.sessionId}_${options.sensorType}_${options.axis}_${Date.now()}.html`;
    const filePath = `${RNFS.DocumentDirectoryPath}/${fileName}`;

    // Write to file
    await RNFS.writeFile(filePath, htmlContent, 'utf8');

    logger.info('HTML report generated:', filePath);

    return {
      success: true,
      filePath,
    };
  } catch (error) {
    logger.error('Failed to generate HTML report:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Share analysis report
 *
 * @param options - Report generation options
 * @param format - Report format ('text' or 'html')
 */
export async function shareReport(
  options: ReportOptions,
  format: 'text' | 'html' = 'text'
): Promise<void> {
  try {
    let result: ReportResult;

    if (format === 'html') {
      result = await generateHTMLReportFile(options);
    } else {
      result = await generateTextReport(options);
    }

    if (!result.success || !result.filePath) {
      throw new Error(result.error || 'Failed to generate report');
    }

    // Share the file
    if (Platform.OS === 'ios') {
      await Share.share({
        url: `file://${result.filePath}`,
        title: '센서 데이터 분석 리포트',
      });
    } else {
      await Share.share({
        title: '센서 데이터 분석 리포트',
        message: await RNFS.readFile(result.filePath, 'utf8'),
      });
    }

    logger.info('Report shared successfully');
  } catch (error) {
    logger.error('Failed to share report:', error);
    throw error;
  }
}

/**
 * Export report as text (for inline sharing without file)
 *
 * @param options - Report generation options
 * @returns Formatted text report
 */
export function exportReportAsText(options: ReportOptions): string {
  return formatAnalysisReport(
    options.analysis,
    options.sensorType,
    options.axis
  );
}

/**
 * Delete report file
 *
 * @param filePath - Path to report file
 */
export async function deleteReport(filePath: string): Promise<void> {
  try {
    const exists = await RNFS.exists(filePath);
    if (exists) {
      await RNFS.unlink(filePath);
      logger.info('Report deleted:', filePath);
    }
  } catch (error) {
    logger.error('Failed to delete report:', error);
    throw error;
  }
}

/**
 * List all generated reports
 *
 * @returns Array of report file paths
 */
export async function listReports(): Promise<string[]> {
  try {
    const files = await RNFS.readDir(RNFS.DocumentDirectoryPath);

    const reportFiles = files
      .filter(
        file =>
          file.isFile() &&
          file.name.startsWith('analysis_') &&
          (file.name.endsWith('.txt') || file.name.endsWith('.html'))
      )
      .map(file => file.path)
      .sort()
      .reverse(); // Most recent first

    return reportFiles;
  } catch (error) {
    logger.error('Failed to list reports:', error);
    return [];
  }
}
